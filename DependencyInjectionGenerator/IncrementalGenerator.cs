using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace DependencyInjectionGenerator
{
    //[Generator] // uncomment to use it (don't forget to comment the other generator)
    public class IncrementalGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext initContext)
        {
            const string attribute = @"// <auto-generated />
[System.AttributeUsage(System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
internal class AddServiceAttribute : System.Attribute
{
}
";
            initContext.RegisterPostInitializationOutput(context => context.AddSource("AddService.Generated.cs", SourceText.From(attribute, Encoding.UTF8)));

            var servicesAdditions = GetServicesAdditions(initContext);
            var namespaceForExtensionMethod = GetNamespaceForExtensionMethod(initContext);

            initContext.RegisterSourceOutput(namespaceForExtensionMethod.Combine(servicesAdditions), (context, pair) =>
            {
                var (ns, lines) = pair;
                var registrations = string.Join(Environment.NewLine, lines.Where(line => line is not null));
                var code = $@"    public static class GeneratedServicesExtension
    {{
        public static void AddServicesToDI(this IServiceCollection services)
        {{
{registrations}{(registrations == "" ? "" : Environment.NewLine)}        }}
    }}";
                if (ns is null)
                {
                    code = UpdateCodeToWorkWithoutNamespace(code);
                }
                else
                {
                    code = $@"namespace {ns}
{{
{code}
}}
";
                }
                code = @"// <auto-generated />
using Microsoft.Extensions.DependencyInjection;

" + code;
                context.AddSource("GeneratedServicesExtension.Generated.cs", SourceText.From(code, Encoding.UTF8));
            });
        }

        private static IncrementalValuesProvider<string?> GetNamespaceForExtensionMethod(IncrementalGeneratorInitializationContext initContext)
        {
            var invocationSyntax = initContext.SyntaxProvider.CreateSyntaxProvider(
                predicate: static (node, _) => node is InvocationExpressionSyntax
                {
                    Expression: MemberAccessExpressionSyntax
                    {
                        Name:
                        {
                            Identifier:
                            {
                                ValueText: "AddServicesToDI"
                            }
                        }
                    }
                },
                transform: static (context, _) => (InvocationExpressionSyntax)context.Node
            );
            var isTopLevelStatement = invocationSyntax.Select(static (i, _) => i.FirstAncestorOrSelf<GlobalStatementSyntax>() is not null);
            var invocationSyntaxWithCompilation = invocationSyntax.Combine(initContext.CompilationProvider);
            var namespacesFromClass = invocationSyntaxWithCompilation.Select(static (pair, _) =>
            {
                var (invocation, compilation) = pair;
                var invocationSemanticModel = compilation.GetSemanticModel(invocation.SyntaxTree);
                var methodSyntax = invocation.FirstAncestorOrSelf<MethodDeclarationSyntax>();
                if (methodSyntax == null)
                    return null;
                var methodSymbol = invocationSemanticModel.GetDeclaredSymbol(methodSyntax);
                if (methodSymbol == null)
                    return null;
                if (methodSymbol.ContainingNamespace.IsGlobalNamespace)
                {
                    return "";
                }
                return methodSymbol.ContainingNamespace.Name.ToString();
            }).Where(ns => ns is not null);
            var namespaceForExtensionMethod = isTopLevelStatement.Combine(namespacesFromClass.Collect()).Select(static (pair, _) =>
            {
                var (isTopLevel, nss) = pair;
                var ns = nss.FirstOrDefault();
                if (isTopLevel || ns == "")
                    return null;
                return ns;
            });
            return namespaceForExtensionMethod;
        }

        private static IncrementalValueProvider<ImmutableArray<string?>> GetServicesAdditions(IncrementalGeneratorInitializationContext initContext)
        {
            var classes = initContext.SyntaxProvider.CreateSyntaxProvider(
                predicate: static (node, _) => node is ClassDeclarationSyntax,
                transform: static (context, _) => (ClassDeclarationSyntax)context.Node
            );
            var classesWithCompilation = classes.Combine(initContext.CompilationProvider);
            var servicesAdditions = classesWithCompilation.Select(static (pair, _) =>
            {
                var (clazz, compilation) = pair;
                var semanticModel = compilation.GetSemanticModel(clazz.SyntaxTree);
                if (semanticModel == null)
                    return null;
                var symbol = semanticModel.GetDeclaredSymbol(clazz);
                return symbol;
            })
            .Where(symbol => symbol is not null)
            .Select((symbol, _) =>
            {
                if (!symbol!.GetAttributes().Any(a => a.AttributeClass?.Name == "AddServiceAttribute"))
                    return null;
                return $"            services.AddScoped<{GetFullName(symbol)}>();";

            })
            .Collect();
            return servicesAdditions;
        }

        private static string UpdateCodeToWorkWithoutNamespace(string code)
        {
            var newClassCodeBuilder = new StringBuilder();
            foreach (var line in code.Split(new[] { @"
" }, StringSplitOptions.None))
            {
                if (line.Length > 4 && line.Substring(0, 4) == "    ")
                    newClassCodeBuilder.AppendLine(line.Substring(4, line.Length - 4));
                else
                    newClassCodeBuilder.AppendLine(line);
            }
            code = newClassCodeBuilder.ToString();
            return code;
        }

        public static string GetFullName(ISymbol symbol)
        {
            var ns = symbol.ContainingNamespace;
            var nss = new List<string>();
            while (ns != null)
            {
                if (string.IsNullOrWhiteSpace(ns.Name))
                    break;
                nss.Add(ns.Name);
                ns = ns.ContainingNamespace;
            }
            nss.Reverse();
            if (nss.Any())
                return $"{string.Join(".", nss)}.{symbol.Name}";
            return symbol.Name;
        }
    }
}


